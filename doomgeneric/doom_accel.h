// doom_accel.h - FPGA Accelerator for DOOM (Batch Rendering v2)
#ifndef DOOM_ACCEL_H
#define DOOM_ACCEL_H

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>

// ============================================================================
// MEMORY MAP (Physical Addresses)
// ============================================================================
#define ACCEL_BASE_ADDR 0xA0010000 // Raster IP register interface (current split-IP Vivado map)
#define ACCEL_PRESENT_BASE_ADDR 0xA0000000 // Present IP register interface (current split-IP Vivado map)
#define ACCEL_SIZE 0x10000

// DDR Shared Memory Layout (32MB total region)
#define PHY_FB_ADDR 0x70000000    // DG_ScreenBuffer (1600x1000x4 = 6.4MB, 8MB reserved)
#define PHY_VIDEO_BUF 0x70800000  // I_VideoBuffer output (320x200 = 64KB)
#define PHY_CMD_BUF 0x70810000    // Command Buffer (128KB = 4000 cmds x 32B)
#define PHY_TEX_ADDR 0x70830000   // Texture Atlas (16MB) - Level textures
#define PHY_CMAP_ADDR 0x71830000  // Colormap + RGB palette (8KB + 768B)
// Stage 5 split path: raster->present handoff buffer in PL BRAM via AXI BRAM Controller.
// Assign this base in Vivado Address Editor for the BRAM controller.
#define PHY_STAGE5_BRAM_BUF 0xA1000000
#define MEM_BLOCK_SIZE 0x02000000 // 32MB total mapped region

// ============================================================================
// COMMAND TYPES
// ============================================================================
#define CMD_TYPE_COLUMN 0 // Vertical wall column
#define CMD_TYPE_SPAN 1   // Horizontal floor/ceiling span

// ============================================================================
// COMMAND BUFFER STRUCTURE (32 bytes per command, cache-aligned)
// Unified structure for both columns (walls) and spans (floors/ceilings)
// ============================================================================
typedef struct __attribute__((packed))
{
    uint8_t cmd_type;    // CMD_TYPE_COLUMN or CMD_TYPE_SPAN  [0]
    uint8_t cmap_index;  // Light level index (0-31)          [1]
    uint16_t x1;         // Start X (for both column and span)[2-3]
    uint16_t x2;         // End X (span only)                 [4-5]
    uint16_t y1;         // Start Y (column: y_start, span: y)[6-7]
    uint16_t y2;         // End Y (column: y_end)             [8-9]
    uint16_t reserved1;  // Padding                           [10-11]
    uint32_t frac;       // Column: texture frac, Span: pos   [12-15]
    uint32_t step;       // Column: texture step, Span: step  [16-19]
    uint32_t tex_offset; // Offset into texture atlas         [20-23]
    uint32_t reserved2;  // Padding                           [24-27]
    uint32_t reserved3;  // Padding to 32 bytes               [28-31]
} DrawCommand;

#define MAX_COMMANDS 4000                                 // Increased for walls + floors + ceilings
#define CMD_BUF_SIZE (MAX_COMMANDS * sizeof(DrawCommand)) // 128KB

// ============================================================================
// FPGA MODES (sent via mode register)
// ============================================================================
#define MODE_IDLE 0          // Do nothing
#define MODE_LOAD_COLORMAP 1 // DMA colormap from DDR -> BRAM (once at level start)
#define MODE_CLEAR_FB 2      // Clear framebuffer BRAM to color 0
#define MODE_DRAW_BATCH 3    // Process all commands from command buffer
#define MODE_DMA_OUT 4       // DMA framebuffer BRAM -> DDR
#define MODE_UPSCALE 5       // 320x200 indexed -> 1600x1000 RGBA (Stage 4.1)
#define MODE_DRAW_AND_DMA 6  // Combined draw + DMA (single handshake)
#define MODE_PRESENT 7       // BRAM framebuffer -> DDR output (scale 1x/5x)
#define MODE_DRAW_AND_PRESENT 8 // Draw batch + present in one invocation

// ============================================================================
// REGISTER OFFSETS (Vitis HLS AXI-Lite CTRL bundle)
// These will be generated by Vitis HLS - update after synthesis!
// ============================================================================
#define REG_CTRL 0x00 // Control: bit0=ap_start, bit1=ap_done, bit2=ap_idle
#define REG_GIE 0x04  // Global Interrupt Enable
#define REG_IER 0x08  // IP Interrupt Enable
#define REG_ISR 0x0C  // IP Interrupt Status

// Pointer addresses (64-bit split) - OFFSETS TO BE UPDATED FROM HLS SYNTHESIS
#define REG_FB_OUT_LO 0x10    // framebuffer_out address low
#define REG_FB_OUT_HI 0x14    // framebuffer_out address high
#define REG_TEX_ATLAS_LO 0x1C // texture_atlas address low
#define REG_TEX_ATLAS_HI 0x20 // texture_atlas address high
#define REG_CMAP_DDR_LO 0x28  // colormap_ddr address low
#define REG_CMAP_DDR_HI 0x2C  // colormap_ddr address high
#define REG_CMD_BUF_LO 0x34   // command_buffer address low
#define REG_CMD_BUF_HI 0x38   // command_buffer address high

// Scalar parameters
#define REG_MODE 0x40         // Mode of operation
#define REG_NUM_COMMANDS 0x48 // Number of commands to process
#define REG_PRESENT_SCALE 0x50 // 1 or 5 for present/upscale output
#define REG_PRESENT_ROWS 0x58  // 1..200 (0 => full height)

// Optional multi-lane framebuffer outputs (Stage 4.3)
#define REG_FB_OUT1_LO 0x60
#define REG_FB_OUT1_HI 0x64
#define REG_FB_OUT2_LO 0x6C
#define REG_FB_OUT2_HI 0x70
#define REG_FB_OUT3_LO 0x78
#define REG_FB_OUT3_HI 0x7C
#define REG_PRESENT_LANES 0x84 // 1 or 4
#define REG_PRESENT_FORMAT 0x8C // 0=XRGB8888, 1=RGB565
#define REG_PRESENT_STRIDE_BYTES 0x94 // destination stride in bytes (0=packed row)
#define REG_RCAS_ENABLE 0x9C // 0=off, 1=on
#define REG_RCAS_STRENGTH 0xA4 // 0..255

// Present output formats
#define PRESENT_FMT_XRGB8888 0
#define PRESENT_FMT_RGB565 1

// ============================================================================
// EXTERN GLOBALS
// ============================================================================
extern volatile uint32_t *accel_regs;
extern volatile uint32_t *present_regs;
extern void *shared_mem_virt;
extern uint32_t *DG_ScreenBuffer;

// Memory region pointers (virtual addresses)
extern uint8_t *I_VideoBuffer_shared; // 320x200 output buffer
extern DrawCommand *cmd_buffer_virt;  // Command buffer
extern uint8_t *tex_atlas_virt;       // Texture atlas
extern uint8_t *colormap_virt;        // Colormap

// Command buffer state
extern uint32_t cmd_count;        // Current number of queued commands
extern uint32_t tex_atlas_offset; // Current texture atlas write offset

// Debug flags
extern int debug_sw_fallback; // 1 = software rendering, 0 = FPGA

// Runtime performance counters (sampled once per second by doomgeneric_udp)
typedef struct
{
    uint32_t flush_calls;
    uint32_t mid_frame_flushes;
    uint32_t queued_columns;
    uint32_t queued_spans;
    uint32_t max_cmds_seen;

    uint32_t tex_cache_entries;
    uint32_t tex_cache_lookups;
    uint32_t tex_cache_hits;
    uint32_t tex_cache_misses;
    uint32_t tex_cache_failed_inserts;
    uint32_t tex_atlas_wraps;
    uint64_t tex_upload_bytes;

    uint64_t fpga_wait_ns;
} HWPerfStats;

// ============================================================================
// FUNCTION PROTOTYPES
// ============================================================================

// Initialize hardware acceleration (call once at startup)
void Init_Doom_Accel(void);

// Upload colormap to DDR and load into FPGA BRAM (call once after WAD load)
void Upload_Colormap(const uint8_t *colormaps_ptr, int size);

// Upload RGB palette (256x3) used by PL upscale color expansion.
void Upload_RGBPalette(const uint8_t *palette_rgb, int size);

// Upload texture data to atlas, return offset (call during level load)
uint32_t Upload_Texture_Data(const uint8_t *source, int size);

// Reset texture atlas for new level
void Reset_Texture_Atlas(void);

// === FRAME RENDERING API ===

// Start a new frame: clear command buffer (does NOT clear framebuffer BRAM)
void HW_StartFrame(void);

// Queue a column draw command (call during wall rendering)
void HW_QueueColumn(int x, int y_start, int y_end, uint32_t frac, uint32_t step,
                    uint32_t tex_offset, int light_level);

// Queue a span draw command (call during floor/ceiling rendering)
void HW_QueueSpan(int y, int x1, int x2, uint32_t position, uint32_t step,
                  uint32_t tex_offset, int light_level);

// Execute queued commands and DMA to DDR (call after floors, before sprites)
void HW_FlushBatch(void);

// Called at end of frame (no-op now since HW_FlushBatch does the work)
void HW_FinishFrame(void);

// Clear the framebuffer BRAM (call at level start, not every frame!)
void HW_ClearFramebuffer(void);

// Stage 4.1: PL fullres upscale control and execution.
void HW_SetPLUpscaleEnabled(int enable);
int HW_IsPLUpscaleEnabled(void);
uint64_t HW_UpscaleFrame(void);
void HW_SetRasterSharedBRAM(int enable);
void HW_SetPLCompositeEnabled(int enable);
int HW_IsPLCompositeEnabled(void);
void HW_SetPresentOutputPhys(uint32_t phys_addr);
uint32_t HW_GetPresentOutputPhys(void);
void HW_SetPresentOutputFormat(int format);
int HW_GetPresentOutputFormat(void);
void HW_SetPresentStrideBytes(uint32_t stride_bytes);
uint32_t HW_GetPresentStrideBytes(void);
void HW_SetRCASLite(int enable, uint32_t strength);
int HW_GetRCASLiteEnabled(void);
uint32_t HW_GetRCASLiteStrength(void);

// Stage 4.3: multi-lane output control (1 lane or 4 lanes).
void HW_SetPresentLanes(int lanes);
int HW_GetPresentLanes(void);

// Copy current hardware/texture perf counters and reset interval counters.
void HW_GetAndResetPerfStats(HWPerfStats *out);

#endif
